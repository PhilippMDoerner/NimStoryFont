{"version":3,"file":"ngrx-operators.mjs","sources":["../../../../modules/operators/src/concat_latest_from.ts","../../../../modules/operators/src/map-response.ts","../../../../modules/operators/src/tap-response.ts","../../../../modules/operators/index.ts","../../../../modules/operators/ngrx-operators.ts"],"sourcesContent":["import {\n  Observable,\n  ObservableInput,\n  of,\n  ObservedValueOf,\n  OperatorFunction,\n} from 'rxjs';\nimport { concatMap, withLatestFrom } from 'rxjs/operators';\n\n// The array overload is needed first because we want to maintain the proper order in the resulting tuple\nexport function concatLatestFrom<T extends Observable<unknown>[], V>(\n  observablesFactory: (value: V) => [...T]\n): OperatorFunction<V, [V, ...{ [i in keyof T]: ObservedValueOf<T[i]> }]>;\nexport function concatLatestFrom<T extends Observable<unknown>, V>(\n  observableFactory: (value: V) => T\n): OperatorFunction<V, [V, ObservedValueOf<T>]>;\n/**\n * `concatLatestFrom` combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n *\n * @usageNotes\n *\n * Select the active customer from the NgRx Store\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/operators';\n * import * as fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom(() => this.store.select(fromCustomers.selectActiveCustomer))\n * )\n * ```\n *\n * Select a customer from the NgRx Store by its id that is available on the action\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/operators';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom((action) => this.store.select(fromCustomers.selectCustomer(action.customerId)))\n * )\n * ```\n */\nexport function concatLatestFrom<\n  T extends ObservableInput<unknown>[] | ObservableInput<unknown>,\n  V,\n  R = [\n    V,\n    ...(T extends ObservableInput<unknown>[]\n      ? { [i in keyof T]: ObservedValueOf<T[i]> }\n      : [ObservedValueOf<T>])\n  ]\n>(observablesFactory: (value: V) => T): OperatorFunction<V, R> {\n  return concatMap((value) => {\n    const observables = observablesFactory(value);\n    const observablesAsArray = Array.isArray(observables)\n      ? observables\n      : [observables];\n    return of(value).pipe(\n      withLatestFrom(...observablesAsArray)\n    ) as unknown as Observable<R>;\n  });\n}\n","import { Observable, of } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\n\ntype MapResponseObserver<T, E, R1, R2> = {\n  next: (value: T) => R1;\n  error: (error: E) => R2;\n};\n\n/**\n * `mapResponse` is a map operator with included error handling.\n * It is similar to `tapResponse`, but allows to map the response as well.\n *\n * The main use case is for NgRx Effects which requires an action to be dispatched.\n *\n * @usageNotes\n * ```ts\n * export const loadAllUsers = createEffect((\n *   actions$ = inject(Actions),\n *   usersService = inject(UsersService)\n * ) => {\n *   return actions$.pipe(\n *     ofType(UsersPageActions.opened),\n *     exhaustMap(() => {\n *       return usersService.getAll().pipe(\n *         mapResponse({\n *           next: (users) => UsersApiActions.usersLoadedSuccess({ users }),\n *           error: (error) => UsersApiActions.usersLoadedFailure({ error }),\n *         })\n *       );\n *     })\n *   );\n * });\n * ```\n */\nexport function mapResponse<T, E, R1, R2>(\n  observer: MapResponseObserver<T, E, R1, R2>\n): (source$: Observable<T>) => Observable<R1 | R2> {\n  return (source$) =>\n    source$.pipe(\n      map((value) => observer.next(value)),\n      catchError((error) => of(observer.error(error)))\n    );\n}\n","import { EMPTY, Observable } from 'rxjs';\nimport { catchError, finalize, tap } from 'rxjs/operators';\n\ntype TapResponseObserver<T, E> = {\n  next: (value: T) => void;\n  error: (error: E) => void;\n  complete?: () => void;\n  finalize?: () => void;\n};\n\nexport function tapResponse<T, E = unknown>(\n  observer: TapResponseObserver<T, E>\n): (source$: Observable<T>) => Observable<T>;\nexport function tapResponse<T, E = unknown>(\n  next: (value: T) => void,\n  error: (error: E) => void,\n  complete?: () => void\n): (source$: Observable<T>) => Observable<T>;\n/**\n * Handles the response in ComponentStore effects in a safe way, without\n * additional boilerplate. It enforces that the error case is handled and\n * that the effect would still be running should an error occur.\n *\n * Takes optional callbacks for `complete` and `finalize`.\n *\n * @usageNotes\n *\n * ```ts\n * readonly dismissAlert = this.effect<Alert>((alert$) => {\n *   return alert$.pipe(\n *     concatMap(\n *       (alert) => this.alertsService.dismissAlert(alert).pipe(\n *         tapResponse(\n *           (dismissedAlert) => this.alertDismissed(dismissedAlert),\n *           (error: { message: string }) => this.logError(error.message)\n *         )\n *       )\n *     )\n *   );\n * });\n *\n * readonly loadUsers = this.effect<void>((trigger$) => {\n *   return trigger$.pipe(\n *     tap(() => this.patchState({ loading: true })),\n *     exhaustMap(() =>\n *       this.usersService.getAll().pipe(\n *         tapResponse({\n *           next: (users) => this.patchState({ users }),\n *           error: (error: HttpErrorResponse) => this.logError(error.message),\n *           finalize: () => this.patchState({ loading: false }),\n *         })\n *       )\n *     )\n *   );\n * });\n * ```\n */\nexport function tapResponse<T, E>(\n  observerOrNext: TapResponseObserver<T, E> | ((value: T) => void),\n  error?: (error: E) => void,\n  complete?: () => void\n): (source$: Observable<T>) => Observable<T> {\n  const observer: TapResponseObserver<T, E> =\n    typeof observerOrNext === 'function'\n      ? {\n          next: observerOrNext,\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          error: error!,\n          complete,\n        }\n      : observerOrNext;\n\n  return (source) =>\n    source.pipe(\n      tap({ next: observer.next, complete: observer.complete }),\n      catchError((error) => {\n        observer.error(error);\n        return EMPTY;\n      }),\n      observer.finalize ? finalize(observer.finalize) : (source$) => source$\n    );\n}\n","/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\nexport * from './src/index';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BG;AACG,SAAU,gBAAgB,CAS9B,kBAAmC,EAAA;AACnC,IAAA,OAAO,SAAS,CAAC,CAAC,KAAK,KAAI;AACzB,QAAA,MAAM,WAAW,GAAG,kBAAkB,CAAC,KAAK,CAAC;AAC7C,QAAA,MAAM,kBAAkB,GAAG,KAAK,CAAC,OAAO,CAAC,WAAW;AAClD,cAAE;AACF,cAAE,CAAC,WAAW,CAAC;AACjB,QAAA,OAAO,EAAE,CAAC,KAAK,CAAC,CAAC,IAAI,CACnB,cAAc,CAAC,GAAG,kBAAkB,CAAC,CACV;AAC/B,KAAC,CAAC;AACJ;;ACxDA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBG;AACG,SAAU,WAAW,CACzB,QAA2C,EAAA;AAE3C,IAAA,OAAO,CAAC,OAAO,KACb,OAAO,CAAC,IAAI,CACV,GAAG,CAAC,CAAC,KAAK,KAAK,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EACpC,UAAU,CAAC,CAAC,KAAK,KAAK,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CACjD;AACL;;ACxBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCG;SACa,WAAW,CACzB,cAAgE,EAChE,KAA0B,EAC1B,QAAqB,EAAA;AAErB,IAAA,MAAM,QAAQ,GACZ,OAAO,cAAc,KAAK;AACxB,UAAE;AACE,YAAA,IAAI,EAAE,cAAc;;AAEpB,YAAA,KAAK,EAAE,KAAM;YACb,QAAQ;AACT;UACD,cAAc;AAEpB,IAAA,OAAO,CAAC,MAAM,KACZ,MAAM,CAAC,IAAI,CACT,GAAG,CAAC,EAAE,IAAI,EAAE,QAAQ,CAAC,IAAI,EAAE,QAAQ,EAAE,QAAQ,CAAC,QAAQ,EAAE,CAAC,EACzD,UAAU,CAAC,CAAC,KAAK,KAAI;AACnB,QAAA,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC;AACrB,QAAA,OAAO,KAAK;KACb,CAAC,EACF,QAAQ,CAAC,QAAQ,GAAG,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,OAAO,KAAK,OAAO,CACvE;AACL;;ACjFA;;;;AAIG;;ACJH;;AAEG;;;;"}