{"version":3,"file":"explore.js","sourceRoot":"","sources":["../src/lib/explore.ts"],"names":[],"mappings":"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","sourcesContent":["import convert from 'convert-source-map';\nimport path from 'path';\nimport { BasicSourceMapConsumer, IndexedSourceMapConsumer, SourceMapConsumer } from 'source-map';\nimport gzipSize from 'gzip-size';\nimport { mapKeys } from 'lodash';\n\nimport { getBundleName } from './api';\nimport {\n  getFileContent,\n  getCommonPathPrefix,\n  getFirstRegexMatch,\n  detectEOL,\n  getOccurrencesCount,\n  isEOLAtPosition,\n  mergeRanges,\n} from './helpers';\nimport { AppError } from './app-error';\nimport { setCoveredSizes } from './coverage';\n\nimport type {\n  Bundle,\n  CoverageRange,\n  ExploreBundleResult,\n  ExploreOptions,\n  File,\n  FileDataMap,\n  FileSizes,\n  MappingRange,\n} from './types';\n\nexport const UNMAPPED_KEY = '[unmapped]';\nexport const SOURCE_MAP_COMMENT_KEY = '[sourceMappingURL]';\nexport const NO_SOURCE_KEY = '[no source]';\nexport const EOL_KEY = '[EOLs]';\n\nexport const SPECIAL_FILENAMES = [UNMAPPED_KEY, SOURCE_MAP_COMMENT_KEY, NO_SOURCE_KEY, EOL_KEY];\n\n/**\n * Analyze a bundle\n */\nexport async function exploreBundle(\n  bundle: Bundle,\n  options: ExploreOptions\n): Promise<ExploreBundleResult> {\n  const { code, map, coverageRanges } = bundle;\n\n  const sourceMapData = await loadSourceMap(code, map);\n\n  const sizes = computeFileSizes(sourceMapData, options, coverageRanges);\n\n  const files = adjustSourcePaths(sizes.files, options);\n\n  // Free Wasm data\n  sourceMapData.consumer.destroy();\n\n  return {\n    bundleName: getBundleName(bundle),\n    ...sizes,\n    files,\n  };\n}\n\ntype Consumer = BasicSourceMapConsumer | IndexedSourceMapConsumer;\n\ninterface SourceMapData {\n  consumer: Consumer;\n  codeFileContent: string;\n}\n\n/**\n * Get source map\n */\nasync function loadSourceMap(codeFile: File, sourceMapFile?: File): Promise<SourceMapData> {\n  const codeFileContent = getFileContent(codeFile);\n\n  let consumer: Consumer;\n\n  if (sourceMapFile) {\n    const sourceMapFileContent = getFileContent(sourceMapFile);\n\n    consumer = await new SourceMapConsumer(sourceMapFileContent);\n  } else {\n    // Try to read a source map from a 'sourceMappingURL' comment.\n    let converter = convert.fromSource(codeFileContent);\n\n    if (!converter && !Buffer.isBuffer(codeFile)) {\n      converter = convert.fromMapFileSource(codeFileContent, path.dirname(codeFile));\n    }\n\n    if (!converter) {\n      throw new AppError({ code: 'NoSourceMap' });\n    }\n\n    consumer = await new SourceMapConsumer(converter.toJSON());\n  }\n\n  if (!consumer) {\n    throw new AppError({ code: 'NoSourceMap' });\n  }\n\n  return {\n    consumer,\n    codeFileContent,\n  };\n}\n\nconst COMMENT_REGEX = convert.commentRegex;\nconst MAP_FILE_COMMENT_REGEX = convert.mapFileCommentRegex;\n\n/**\n * Extract either source map comment/file\n */\nfunction getSourceMapComment(fileContent: string): string {\n  const sourceMapComment =\n    getFirstRegexMatch(COMMENT_REGEX, fileContent) ||\n    getFirstRegexMatch(MAP_FILE_COMMENT_REGEX, fileContent) ||\n    '';\n\n  // Remove trailing EOLs\n  return sourceMapComment.trim();\n}\n\ninterface ComputeFileSizesContext {\n  generatedLine: number;\n  generatedColumn: number;\n  line: string;\n  source: string | null;\n  consumer: Consumer;\n  mapReferenceEOLSources: Set<string>;\n}\n\n/**\n * Check if source map references EOL (see https://github.com/microsoft/TypeScript/issues/34695)\n */\nfunction isReferencingEOL(context: ComputeFileSizesContext, maxColumnIndex: number): boolean {\n  const { generatedLine, generatedColumn, source, consumer } = context;\n\n  // Ignore difference more than EOL max length (\\r\\n)\n  if (maxColumnIndex - generatedColumn > 2) {\n    return false;\n  }\n\n  // Ignore mapping w/o source\n  if (!source) {\n    return false;\n  }\n\n  // Don't check the same source twice. It covers most cases even though not 100% reliable\n  if (context.mapReferenceEOLSources.has(source)) {\n    return true;\n  }\n\n  const content = consumer.sourceContentFor(source, true);\n\n  // Content is needed to detect EOL\n  if (!content) {\n    return false;\n  }\n\n  const { line, column } = consumer.originalPositionFor({\n    line: generatedLine,\n    column: generatedColumn,\n  });\n\n  if (line === null || column === null) {\n    return false;\n  }\n\n  if (isEOLAtPosition(content, [line, column])) {\n    context.mapReferenceEOLSources.add(source);\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction checkInvalidMappingColumn(context: ComputeFileSizesContext): void {\n  const { line, generatedLine, generatedColumn } = context;\n  const maxColumnIndex = line.length - 1;\n\n  if (generatedColumn > maxColumnIndex) {\n    if (isReferencingEOL(context, maxColumnIndex)) {\n      return;\n    }\n\n    throw new AppError({\n      code: 'InvalidMappingColumn',\n      generatedLine,\n      generatedColumn,\n      maxColumn: line.length,\n    });\n  }\n}\n\n/**\n * Calculate the number of bytes contributed by each source file\n */\nfunction computeFileSizes(\n  sourceMapData: SourceMapData,\n  options: ExploreOptions,\n  coverageRanges?: CoverageRange[][]\n): FileSizes {\n  const { consumer, codeFileContent: fileContent } = sourceMapData;\n\n  const sourceMapComment = getSourceMapComment(fileContent);\n  // Remove inline source map comment, source map file comment and trailing EOLs\n  const sourceContent = fileContent.replace(sourceMapComment, '').trim();\n\n  const eol = detectEOL(fileContent);\n  // Assume only one type of EOL is used\n  const lines = sourceContent.split(eol);\n\n  const mappingRanges: MappingRange[][] = [];\n\n  const context: ComputeFileSizesContext = {\n    generatedLine: -1,\n    generatedColumn: -1,\n    line: '',\n    source: null,\n    consumer,\n    mapReferenceEOLSources: new Set(),\n  };\n\n  consumer.computeColumnSpans();\n  consumer.eachMapping(({ source, generatedLine, generatedColumn, lastGeneratedColumn }) => {\n    // Columns are 0-based, Lines are 1-based\n\n    const lineIndex = generatedLine - 1;\n    const line = lines[lineIndex];\n\n    if (line === undefined) {\n      if (options.noBorderChecks) {\n        return;\n      }\n\n      throw new AppError({\n        code: 'InvalidMappingLine',\n        generatedLine,\n        maxLine: lines.length,\n      });\n    }\n\n    context.generatedLine = generatedLine;\n    context.generatedColumn = lastGeneratedColumn || generatedColumn;\n    context.line = line;\n    context.source = source;\n\n    if (!options.noBorderChecks) {\n      checkInvalidMappingColumn(context);\n    }\n\n    const start = generatedColumn;\n    const end = lastGeneratedColumn === null ? line.length - 1 : lastGeneratedColumn;\n\n    const lineRanges = mappingRanges[lineIndex] || [];\n\n    lineRanges.push({\n      start,\n      end,\n      source: source === null ? NO_SOURCE_KEY : source,\n    });\n\n    mappingRanges[lineIndex] = lineRanges;\n  });\n\n  let files: FileDataMap = {};\n  let mappedBytes = 0;\n\n  // To account unicode measure byte length rather than symbols count\n  const getSize = options.gzip ? gzipSize.sync : Buffer.byteLength;\n\n  mappingRanges.forEach((lineRanges, lineIndex) => {\n    const line = lines[lineIndex];\n    const mergedRanges = mergeRanges(lineRanges);\n\n    mergedRanges.forEach(({ start, end, source }) => {\n      const rangeString = line.substring(start, end + 1);\n      const rangeByteLength = getSize(rangeString);\n\n      if (!files[source]) {\n        files[source] = { size: 0 };\n      }\n\n      files[source].size += rangeByteLength;\n\n      mappedBytes += rangeByteLength;\n    });\n\n    if (coverageRanges) {\n      files = setCoveredSizes(line, files, mergedRanges, coverageRanges[lineIndex]);\n    }\n  });\n\n  const sourceMapCommentBytes = getSize(sourceMapComment);\n  const eolBytes = getOccurrencesCount(eol, fileContent) * Buffer.byteLength(eol);\n  const totalBytes = getSize(fileContent);\n  let unmappedBytes: number | undefined;\n\n  if (!options.excludeSourceMapComment) {\n    files[SOURCE_MAP_COMMENT_KEY] = { size: sourceMapCommentBytes };\n  }\n\n  if (!options.onlyMapped) {\n    unmappedBytes = totalBytes - mappedBytes - sourceMapCommentBytes - eolBytes;\n    files[UNMAPPED_KEY] = { size: unmappedBytes };\n  }\n\n  if (eolBytes > 0) {\n    files[EOL_KEY] = { size: eolBytes };\n  }\n\n  return {\n    ...(options.excludeSourceMapComment\n      ? { totalBytes: totalBytes - sourceMapCommentBytes }\n      : { totalBytes }),\n    mappedBytes,\n    ...(!options.onlyMapped && { unmappedBytes }),\n    eolBytes,\n    sourceMapCommentBytes,\n    files,\n  };\n}\n\nexport function adjustSourcePaths(fileSizeMap: FileDataMap, options: ExploreOptions): FileDataMap {\n  if (!options.noRoot) {\n    const prefix = getCommonPathPrefix(Object.keys(fileSizeMap));\n    const length = prefix.length;\n\n    if (length) {\n      fileSizeMap = mapKeys(fileSizeMap, (size, source) => source.slice(length));\n    }\n  }\n\n  if (options.replaceMap) {\n    fileSizeMap = Object.entries(options.replaceMap).reduce((result, [before, after]) => {\n      const regexp = new RegExp(before, 'g');\n\n      return mapKeys(result, (size, source) => source.replace(regexp, after));\n    }, fileSizeMap);\n  }\n\n  return fileSizeMap;\n}\n"]}