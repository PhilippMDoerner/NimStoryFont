{"version":3,"file":"api.js","sourceRoot":"","sources":["../src/lib/api.ts"],"names":[],"mappings":"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","sourcesContent":["import glob from 'glob';\nimport { partition, flatMap, isString, toPairs, fromPairs, sortBy } from 'lodash';\n\nimport { exploreBundle, UNMAPPED_KEY, SPECIAL_FILENAMES } from './explore';\nimport { AppError, getErrorMessage } from './app-error';\nimport { formatOutput, saveOutputToFile } from './output';\nimport { addCoverageRanges } from './coverage';\n\nimport type {\n  Bundle,\n  BundlesAndFileTokens,\n  ExploreBundleResult,\n  ExploreErrorResult,\n  ExploreOptions,\n  ExploreResult,\n} from './types';\n\nfunction adjustOptions(options: ExploreOptions): ExploreOptions {\n  /* Unmapped bytes cannot be calculate because it's impossible to get total size by summing files'\n     sizes when calculating gzip size for a file. */\n  if (options.gzip) {\n    options.onlyMapped = true;\n  }\n\n  return options;\n}\n\n/**\n * Analyze bundle(s)\n */\nexport async function explore(\n  bundlesAndFileTokens: BundlesAndFileTokens,\n  options: ExploreOptions = {}\n): Promise<ExploreResult> {\n  bundlesAndFileTokens = Array.isArray(bundlesAndFileTokens)\n    ? bundlesAndFileTokens\n    : [bundlesAndFileTokens];\n\n  if (bundlesAndFileTokens.length === 0) {\n    throw new AppError({ code: 'NoBundles' });\n  }\n\n  adjustOptions(options);\n\n  // Separate bundles from file tokens\n  const [fileTokens, bundles] = partition(bundlesAndFileTokens, isString);\n\n  // Get bundles from file tokens\n  bundles.push(...getBundles(fileTokens));\n\n  addCoverageRanges(bundles, options.coverage);\n\n  const results = await Promise.all(\n    bundles.map((bundle) =>\n      exploreBundle(bundle, options).catch<ExploreErrorResult>((error) =>\n        onExploreError(bundle, error)\n      )\n    )\n  );\n\n  const exploreResult = getExploreResult(results, options);\n\n  // Reject if none of results is successful\n  if (exploreResult.bundles.length === 0) {\n    return Promise.reject(exploreResult);\n  }\n\n  saveOutputToFile(exploreResult, options);\n\n  return exploreResult;\n}\n\n/**\n * Expand list of file tokens into a list of bundles\n */\nexport function getBundles(fileTokens: string[]): Bundle[] {\n  const filenames = flatMap(fileTokens, (filePath) =>\n    glob.hasMagic(filePath) ? expandGlob(filePath) : filePath\n  );\n\n  const [mapFilenames, codeFilenames] = partition(filenames, (filename) =>\n    filename.endsWith('.map')\n  );\n\n  return codeFilenames.map<Bundle>((code) => ({\n    code,\n    map: mapFilenames.find((filename) => filename === `${code}.map`),\n  }));\n}\n\nfunction expandGlob(pattern: string): string[] {\n  // Make sure pattern match `.map` files as well\n  if (pattern.endsWith('.js')) {\n    pattern = `${pattern}?(.map)`;\n  }\n\n  return glob.sync(pattern);\n}\n\nexport function getBundleName(bundle: Bundle): string {\n  return Buffer.isBuffer(bundle.code) ? 'Buffer' : bundle.code;\n}\n\n/**\n * Handle error during bundle processing\n */\nfunction onExploreError(bundle: Bundle, error: NodeJS.ErrnoException): ExploreErrorResult {\n  return {\n    bundleName: getBundleName(bundle),\n    code: error.code || 'Unknown',\n    message: error.message,\n    error,\n  };\n}\n\nfunction sortFilenames(bundles: ExploreBundleResult[]): ExploreBundleResult[] {\n  return bundles.map((bundle) => ({\n    ...bundle,\n    files: fromPairs(sortBy(toPairs(bundle.files), 0)),\n  }));\n}\n\nfunction getExploreResult(\n  results: (ExploreBundleResult | ExploreErrorResult)[],\n  options: ExploreOptions\n): ExploreResult {\n  const [bundles, errors] = partition(\n    results,\n    (result): result is ExploreBundleResult => 'files' in result\n  );\n\n  let sortedBundles = sortBy(bundles, (bundle) => bundle.bundleName);\n\n  if (options.sort) {\n    sortedBundles = sortFilenames(sortedBundles);\n  }\n\n  errors.push(...getPostExploreErrors(bundles));\n\n  return {\n    bundles: sortedBundles,\n    errors,\n    ...(bundles.length > 0 && { output: formatOutput(sortedBundles, options) }),\n  };\n}\n\nfunction getPostExploreErrors(exploreBundleResults: ExploreBundleResult[]): ExploreErrorResult[] {\n  const errors: ExploreErrorResult[] = [];\n\n  const isSingleBundle = exploreBundleResults.length === 1;\n\n  for (const result of exploreBundleResults) {\n    const { bundleName, files, totalBytes } = result;\n\n    // Check if source map contains only one file - this make result useless when exploring single bundle\n    if (isSingleBundle) {\n      const filenames = Object.keys(files).filter(\n        (filename) => !SPECIAL_FILENAMES.includes(filename)\n      );\n\n      if (filenames.length === 1) {\n        errors.push({\n          bundleName,\n          isWarning: true,\n          code: 'OneSourceSourceMap',\n          message: getErrorMessage({ code: 'OneSourceSourceMap', filename: filenames[0] }),\n        });\n      }\n    }\n\n    if (files[UNMAPPED_KEY] !== undefined) {\n      const { size: unmappedBytes } = files[UNMAPPED_KEY];\n\n      if (unmappedBytes) {\n        errors.push({\n          bundleName,\n          isWarning: true,\n          code: 'UnmappedBytes',\n          message: getErrorMessage({ code: 'UnmappedBytes', unmappedBytes, totalBytes }),\n        });\n      }\n    }\n  }\n\n  return errors;\n}\n"]}