{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../src/lib/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import fs from 'fs';\n\nimport type { MappingRange } from './types';\n\nexport function getFileContent(file: Buffer | string): string {\n  const buffer = Buffer.isBuffer(file) ? file : fs.readFileSync(file);\n\n  return buffer.toString();\n}\n\nconst BYTE_SIZES = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n// Bytes\nconst SIZE_BASE = 1024;\n\n/**\n * Format number of bytes as string\n * Source @see https://stackoverflow.com/a/18650828/388951\n */\nexport function formatBytes(bytes: number, decimals = 2): string {\n  if (bytes === 0) return `0 ${BYTE_SIZES[0]}`;\n\n  const exponent = Math.floor(Math.log(bytes) / Math.log(SIZE_BASE));\n  const value = bytes / Math.pow(SIZE_BASE, exponent);\n\n  // `parseFloat` removes trailing zero\n  return `${parseFloat(value.toFixed(decimals))} ${BYTE_SIZES[exponent]}`;\n}\n\nexport function formatPercent(value: number, total: number, fractionDigits?: number): string {\n  return ((100.0 * value) / total).toFixed(fractionDigits);\n}\n\nconst PATH_SEPARATOR_REGEX = /(\\/)/;\n\n/**\n * Find common path prefix\n * Source @see http://stackoverflow.com/a/1917041/388951\n * @param paths List of filenames\n */\nexport function getCommonPathPrefix(paths: string[]): string {\n  if (paths.length < 2) return '';\n\n  const A = paths.concat().sort();\n  const a1 = A[0].split(PATH_SEPARATOR_REGEX);\n  const a2 = A[A.length - 1].split(PATH_SEPARATOR_REGEX);\n  const L = a1.length;\n\n  let i = 0;\n\n  while (i < L && a1[i] === a2[i]) i++;\n\n  return a1.slice(0, i).join('');\n}\n\nexport function getFirstRegexMatch(regex: RegExp, string: string): string | null {\n  const match = string.match(regex);\n\n  return match ? match[0] : null;\n}\n\nconst LF = '\\n';\nconst CR_LF = '\\r\\n';\n\nexport function detectEOL(content: string): string {\n  return content.includes(CR_LF) ? CR_LF : LF;\n}\n\n/**\n * Get `subString` occurrences count in `string`\n */\nexport function getOccurrencesCount(subString: string, string: string): number {\n  let count = 0;\n  let position = string.indexOf(subString);\n  const subStringLength = subString.length;\n\n  while (position !== -1) {\n    count += 1;\n    position = string.indexOf(subString, position + subStringLength);\n  }\n\n  return count;\n}\n\nexport function isEOLAtPosition(string: string, [line, column]: [number, number]): boolean {\n  const eol = detectEOL(string);\n  const eolLength = eol.length;\n\n  let lineOffset = 0;\n\n  for (let lineIndex = 1; lineIndex < line; lineIndex += 1) {\n    lineOffset = string.indexOf(eol, lineOffset);\n\n    if (lineOffset === -1) {\n      return false;\n    }\n\n    lineOffset += eolLength;\n  }\n\n  return string.substr(lineOffset + column, eolLength) === eol;\n}\n\n/**\n * Merge consecutive ranges with the same source\n */\nexport function mergeRanges(ranges: MappingRange[]): MappingRange[] {\n  const mergedRanges: MappingRange[] = [];\n  const rangesCount = ranges.length;\n\n  if (rangesCount === 1) {\n    return ranges;\n  }\n\n  let { start, end, source } = ranges[0];\n\n  for (let i = 1; i < rangesCount; i += 1) {\n    const isSourceMatch = ranges[i].source === ranges[i - 1].source;\n    const isConsecutive = ranges[i].start - ranges[i - 1].end === 1;\n\n    if (isSourceMatch && isConsecutive) {\n      end = ranges[i].end;\n    } else {\n      mergedRanges.push({ start, end, source });\n\n      ({ start, end, source } = ranges[i]);\n    }\n  }\n\n  mergedRanges.push({ start, end, source });\n\n  return mergedRanges;\n}\n"]}